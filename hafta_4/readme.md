# ğŸ“— SÄ±nÄ±f ve Nesne KavramlarÄ±

Nesne (Object) Nedir?


Nesne tanÄ±mÄ±nÄ±n TDK'da ki tanÄ±mÄ±na bir bakalÄ±m :


1. Ä°sim belli bir aÄŸÄ±rlÄ±ÄŸÄ± ve hacmi, rengi olan her tÃ¼rlÃ¼ cansÄ±z varlÄ±k, ÅŸey, obje.


2. Ä°sim, dil bilgisi GeÃ§iÅŸli fiili bÃ¼tÃ¼nleyen yalÄ±n veya belirtme durumunda bulunan tÃ¼mleÃ§: Ali bir kitap almÄ±ÅŸ cÃ¼mlesinde kitap nesnedir.


3. Ä°sim, felsefe Ã–znenin dÄ±ÅŸÄ±nda kalan her konu, obje: "Her nesne ve olaya alaycÄ± bir gÃ¶zle bakmak ilkesinden yola Ã§Ä±kar bu gÃ¶rÃ¼ÅŸ." - SalÃ¢h Birsel


Nesnelere Ã–rnekler


1. Araba, telefon, elma, Ã¶rdek, kalem gibi gÃ¼nlÃ¼k hayatta kullandÄ±ÄŸÄ±mÄ±z eÅŸyalar. 
![img.png](img.png)Ã¼

BildiÄŸimiz gibi her nesnenin kendine ait nitelikleri ve davranÄ±ÅŸlarÄ± vardÄ±r. Nesneler birbirlerinden farklÄ±dÄ±r ve kendi varoluÅŸlarÄ±na gÃ¶re davranÄ±rlar ve kendi kimliklerine sahiptirler.


Nitelik : Nitelik kavramÄ±, bir nesnenin Ã¶zellikleridir ve nesnenin mevcut durumunu tanÄ±mlar. Mesela bir Ã¶rdeÄŸin rengi ve aÄŸÄ±rlÄ±ÄŸÄ± o Ã¶rdeÄŸin nitelikleridir. Bir Ã¶rdeÄŸimiz rengi siyah, diÄŸer Ã¶rdeÄŸimizin rengi beyazdÄ±r. Bu durumda her iki nesne (yani Ã¶rdek) nitelikleri sebebi ile birbirilerinden baÄŸÄ±msÄ±zdÄ±rlar.


DavranÄ±ÅŸ : Bir nesnenin kendine Ã¶zel yaptÄ±ÄŸÄ± eylemlerdir. Yine Ã¶rdek Ã¶rneÄŸine bakarsak, bir Ã¶rdek uÃ§abiliyorken diÄŸer bir Ã¶rdek fiziksel durumu gereÄŸi uÃ§amayabilir.


Nesneler hakkÄ±nda bilmemiz gereken bir diÄŸer husus ise, nesneler bir isimdir. Nesnelerin kendilerine ait nitelik ve davranÄ±ÅŸlarÄ± vardÄ±r.


### SÄ±nÄ±f (Class) Nedir?


NYP sÄ±nÄ±flar ve nesneler Ã¼zerine kurulmuÅŸtur, "SÄ±nÄ±flar" bir problemi soyutlamak ve genelleÅŸtirmek iÃ§in kullanÄ±lan yapÄ±lardÄ±r veya kÄ±lavuzlardÄ±r. SÄ±nÄ±flar, bir nesneye ait tÃ¼m Ã¶zellikleri temsil eder. Bu Ã¶zellikler nesnenin ne tÃ¼r nitelikleri ve davranÄ±ÅŸlarÄ± olacaÄŸÄ±nÄ± belirler.


Mesela "Araba" bir sÄ±nÄ±ftÄ±r. Arabalara ait nitelikler renk, hÄ±z, vites sayÄ±sÄ±, yakÄ±t tÃ¼rÃ¼ vb. bir sÃ¼rÃ¼ nitelik olabilir. AyrÄ±ca bazÄ± arabalara Ã¶zel davranÄ±ÅŸlar olabilir, park sensÃ¶rÃ¼, oto pilot, hÄ±z sabitleme gibi arabalarÄ±n kendilerine Ã¶zel davranÄ±ÅŸlarÄ± da olabilir. Bir araba Ã¼retilirken, bir yapÄ±m kÄ±lavuzuna ihtiyaÃ§ vardÄ±r. Programlama da bu kÄ±lavuzlara "SÄ±nÄ±f (Class)" denir.

![img_1.png](img_1.png)

# ğŸ“— Nesne YÃ¶nelik Programlama Nedir?

Nesne YÃ¶nelimli Programlama (Object Oriented Programming), sÄ±nÄ±flar ve nesneler kavramÄ±na dayanan bir programlama yaklaÅŸÄ±mÄ±dÄ±r. Bu yaklaÅŸÄ±mÄ±n amacÄ±, ihtiyaÃ§ duyulan programÄ± daha kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lerek, yÃ¶netilebilir ve yeniden kullanÄ±labilir hale getirmektir. Her kÃ¼Ã§Ã¼k parÃ§anÄ±n kendine ait Ã¶zelliÄŸi, verileri ve diÄŸer kÃ¼Ã§Ã¼k parÃ§alarla nasÄ±l iletiÅŸim kuracaÄŸÄ± bilgileri bulunur.


NYPâ€™de programlar, nesnelerin birbirileriyle etkileÅŸime geÃ§meleri saÄŸlanmasÄ±yla tasarlanÄ±r. Bizler gerÃ§ek hayattaki karmaÅŸÄ±klÄ±ÄŸÄ± bir ÅŸekilde modelleyerek bunu bilgisayarÄ±n anlamasÄ±nÄ± saÄŸlamaktayÄ±z. Modelleme, insanÄ±n problem Ã§Ã¶zmek Ã¼zere eskiden beri kullandÄ±ÄŸÄ± bir yÃ¶ntemdir. BÃ¼yÃ¼kÃ§e bir problemin tamamÄ±nÄ± zihinde canlandÄ±rÄ±p Ã§Ã¶zmeye Ã§alÄ±ÅŸmak yerine, oluÅŸturulacak model ya da modeller Ã¼zerinde hedef sistemin gÃ¶rÃ¼nÃ¼ÅŸÃ¼, davranÄ±ÅŸÄ± ya da bazÄ± durumlarda verdiÄŸi tepkiler gÃ¶zlemlenebilir.


Nesne YÃ¶nelimli Programlama ile bizler yapacaÄŸÄ±mÄ±z her ÅŸeyi bilgisayarÄ±n anlayacaÄŸÄ± ÅŸekilde modelleyip, â€œnesneâ€ halinde aktarÄ±yoruz. BÃ¶ylelikle gerÃ§ek hayatta bizim iÃ§in geÃ§erli olan nesneleri artÄ±k bilgisayarlarÄ±n anlayacaÄŸÄ± hale getirmiÅŸ oluyoruz. Tabi ki kullanÄ±lan programlama dilinin bizlere verdiÄŸi imkanlar dahilinde. BÃ¶ylelikle kodlayan kiÅŸi ile bilgisayar arasÄ±nda dilden baÄŸÄ±msÄ±z bir anlaÅŸma, bir felsefe ortaya Ã§Ä±kmÄ±ÅŸ oluyor. ArtÄ±k bizim iÃ§in â€œarabaâ€ nesnesi ne anlama geliyorsa, bilgisayar iÃ§in de aynÄ± anlama geliyor.


### Neden Nesne YÃ¶nelimli Programlama?

1. NYP, hÄ±zlÄ± ve uygulamasÄ± kolay bir yaklaÅŸÄ±mdÄ±r.
2. NYP, programlar iÃ§in net bir yapÄ± saÄŸlar. 
3. NYP, "Don't Repeat Yourself" yani "Kendini Tekrar Etme" ilkesini uygular ve kodun bakÄ±mÄ±nÄ±, dÃ¼zenlenmesini ve hata ayÄ±klamasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r. 
4. NYP, daha az kod ve daha kÄ±sa geliÅŸtirme sÃ¼resiyle, yeniden kullanÄ±labilir uygulamalar oluÅŸturmayÄ± mÃ¼mkÃ¼n kÄ±lar. 
5. NYP, yapÄ±ya daha sonradan yeni Ã¶zellikler ekleyerek geniÅŸletilebilirlik saÄŸlar. 
6. NYP, problemleri gerÃ§ek hayattaki iÅŸlemlere gÃ¶re modeller. 

# ğŸ“— Modelleme ve Soyut DÃ¼ÅŸÃ¼nme

GerÃ§ek hayattaki problemleri bilgisayarÄ±n sanal ortamÄ±nda Ã§Ã¶zebilmek iÃ§in, ilk Ã¶nce problemin uygun ÅŸekilde bilgisayar ortamÄ±na aktarÄ±lmasÄ± gerekmektedir. Bu iÅŸlem â€œsoyutlama (abstraction)â€ ya da â€œmodelleme (modeling)â€ olarak anÄ±lÄ±r.


Modelleme, insanÄ±n problem Ã§Ã¶zmek Ã¼zere eskiden beri kullandÄ±ÄŸÄ± bir yÃ¶ntemdir. BÃ¼yÃ¼kÃ§e bir problemin tamamÄ±nÄ± zihinde canlandÄ±rÄ±p Ã§Ã¶zmeye Ã§alÄ±ÅŸmak yerine, oluÅŸturulacak model ya da modeller Ã¼zerinde hedef sistemin gÃ¶rÃ¼nÃ¼ÅŸÃ¼, davranÄ±ÅŸÄ± ya da bazÄ± durumlarda verdiÄŸi tepkiler gÃ¶zlemlenebilir.


Model, var olan ya da gerÃ§ekleÅŸtirilmesi planlanan bir sistemi anlamak ya da anlatmak Ã¼zere oluÅŸturulabilir ve birÃ§ok farklÄ± alanda etkili bir ÅŸekilde kullanÄ±lmaktadÄ±r. Ã–rneÄŸin, bir toplu konut inÅŸaatÄ±nÄ± mÃ¼ÅŸterilerine tanÄ±tmak isteyen bir inÅŸaat firmasÄ±, binalarÄ±n yerleÅŸimlerini, renk ve gÃ¶reli bÃ¼yÃ¼klÃ¼klerini gÃ¶rsel olarak ifade eden maket ya da maketler hazÄ±rlar. Bu maketi inceleyen bir kimse, almak istediÄŸi konutun nerede olduÄŸunu, okul binasÄ±na yakÄ±nlÄ±ÄŸÄ±nÄ± ya da anayola ulaÅŸÄ±mÄ±n nasÄ±l olduÄŸunu gÃ¶rerek deÄŸerlendirebilir. Burada model makettir ve â€œhedef sistemi anlatmakâ€ amacÄ±nÄ± yerine getirmektedir.

![img_2.png](img_2.png)

Bir sistemle ilgili birden Ã§ok model oluÅŸturulabilir. Tek bir model ile sistemin tamamÄ±nÄ± gÃ¶rmeye Ã§alÄ±ÅŸmak yerine, Ã¼zerinde Ã§alÄ±ÅŸÄ±lan sistemin farklÄ± yÃ¶nlerini Ã¶ne Ã§Ä±karan modeller hazÄ±rlanabilir. Ã–rneÄŸin inÅŸaat firmasÄ± toplu konutu mÃ¼ÅŸterilere anlatmak Ã¼zere estetik tasarÄ±mÄ± Ã¶n plana Ã§Ä±kan bir maket hazÄ±rlarken, bu toplu konut projesindeki binalarÄ±n elektrik tesisatÄ± iÃ§in farklÄ±, su tesisatÄ± iÃ§in farklÄ±, genel daire gÃ¶rÃ¼nÃ¼mÃ¼ iÃ§in farklÄ± projeler hazÄ±rlar. BÃ¶ylece aynÄ± sistemin farklÄ± yÃ¶nleriyle ilgilenen kimseler, yalnÄ±zca kendilerini ilgilendiren yÃ¶nÃ¼ Ã¶ne Ã§Ä±karan model Ã¼zerinde Ã§alÄ±ÅŸma olanaÄŸÄ± bulurlar.


Modelin mutlaka elle tutulur olmasÄ± da gerekmez. Bilgisayar benzetimi ile de Ã§eÅŸitli modeller oluÅŸturulabilir. Ã–rneÄŸin bir uÃ§aÄŸÄ±n havadaki hareketini incelemek Ã¼zere geliÅŸtirilmiÅŸ bir bilgisayar benzetimi ile uÃ§ak modellenebilir. Kanat uzunluÄŸu ya da gÃ¶vde eÄŸimi gibi parametrelerle oynanarak uÃ§aÄŸÄ±n farklÄ± hava koÅŸullarÄ±nda nasÄ±l davranacaÄŸÄ± anlaÅŸÄ±lmaya Ã§alÄ±ÅŸÄ±labilir. Burada, sistemin davranÄ±ÅŸÄ±nÄ± anlamak amacÄ±yla, sanal ortamda oluÅŸturulmuÅŸ bir model sÃ¶z konusudur.

![img_3.png](img_3.png)

# ğŸ“— SÄ±nÄ±f TanÄ±mlarÄ±

Java Nesne YÃ¶nelimli bir programlama dilidir. Java'daki her ÅŸey, deÄŸiÅŸkenleri ve metotlarÄ± ile birlikte sÄ±nÄ±flar ve nesnelerle iliÅŸkilidir. Ã–rneÄŸin: gerÃ§ek hayatta araba bir nesnedir. Otomobilin aÄŸÄ±rlÄ±k ve renk gibi deÄŸiÅŸkenleri ve sÃ¼rÃ¼ÅŸ ve fren gibi metotlarÄ± vardÄ±r. Nesne yÃ¶nelimli programlamanÄ±n amacÄ± yazdÄ±ÄŸÄ±mÄ±z kodlara soyut bir kavrama dÃ¶nÃ¼ÅŸtÃ¼rmektir.


SÄ±nÄ±flara ait nitelikler ve davranÄ±ÅŸlar vardÄ±r. Programlamada nitelikler iÃ§in deÄŸiÅŸkenler (variable) ,davranÄ±ÅŸlar iÃ§in ise metotlar (method) tanÄ±mlanÄ±r.


### SÃ¶zdizimi (Syntax)

````
class <class_name> {
	<variable>;
	<methods>;
}</methods></variable></class_name>
````
Java'da "sÄ±nÄ±f" tanÄ±mlanÄ±rken "class" deyimi kullanÄ±lÄ±r ve sonrasÄ±nda sÄ±nÄ±f ismi yazÄ±lÄ±r. Java'da sÄ±nÄ±f isimleri her zaman bÃ¼yÃ¼k harf ile baÅŸlamasÄ± gerekmektedir ve oluÅŸturulan Java dosyasÄ± ile aynÄ± isimde olmalÄ±dÄ±r.


SÄ±nÄ±f ismini de verdikten sonra "{" iÅŸareti ile sÄ±nÄ±fa ait kapsamÄ± yani kod bloÄŸunu oluÅŸtururuz. "}" parantezi ile de sÄ±nÄ±fa ait kapsamÄ± kapatÄ±rÄ±z. BÃ¶ylece, sÄ±nÄ±fÄ±mÄ±z iÃ§in yazacaÄŸÄ±mÄ±z kodlar "{}" arasÄ±nda kalan alanda yazÄ±lacaktÄ±r. Bu da sÄ±nÄ±fÄ±n kapsamÄ±nÄ± ifade eder.


SÄ±nÄ±f kod bloÄŸunu aÃ§tÄ±ktan sonra bu kod bloÄŸu iÃ§in deÄŸiÅŸkenleri ve metotlarÄ± yazarÄ±z. UnutmayÄ±nÄ±z ki metotlar da kendilerine ait kod bloklarÄ±, yani kapsamlarÄ± vardÄ±r. OnlarÄ± da "{}" ile belirtiriz.

````
class Car {
    // nitelikler
    String type;
    String model;
    String color;
    int speed;

    // davranÄ±ÅŸlar
    int increaseSpeed(int increment) {
        speed += increment;
        return speed;
    }

    int decreaseSpeed(int decrease) {
        if (speed > 0) {
            speed -= decrease;
        }
        return speed;
    }
    
    void printSpeed() {
        System.out.println("Speed : " + speed);
    }
    // ...
}
````
YukarÄ±da sÄ±nÄ±f ve fonksiyon tanÄ±mlamalarÄ±na detaylÄ±ca yer verilmiÅŸtir.


SÄ±nÄ±flar nesneler oluÅŸturabilmek iÃ§in yazÄ±lÄ±m dÃ¼nyasÄ±nda oluÅŸturulmuÅŸ ÅŸablonladÄ±r. Bu ÅŸablon nesne ile ilgili modellenecek tÃ¼m Ã¶zellikleri ve davranÄ±ÅŸlarÄ± bir taslak halinde kodlanmasÄ±nÄ± saÄŸlar. BÃ¶ylece, tanÄ±mlanmÄ±ÅŸ bir sÄ±nÄ±ftan binlerce nesne oluÅŸturabiliriz.


# ğŸ“— Nesne OluÅŸturma ve SÄ±nÄ±f MetotlarÄ±


SÄ±nÄ±flar nesneleri tarif eden ÅŸablonlardÄ±. Nesneler ise bu ÅŸablonlardan Ã¼retilen fiziksel yapÄ±lardÄ±r. Her Ã¼retilen nesne Hesap HafÄ±za BÃ¶lgesi'nde tutulur. BÃ¶ylece sÄ±nÄ±ftan fiziksel karÅŸÄ±lÄ±ÄŸÄ± olan bir yapÄ± elde etmiÅŸ oluruz. SÄ±nÄ±ftan onlarca, yÃ¼zlerce nesne yaratabiliriz. Hepsi de hafÄ±za baÅŸka adresleri gÃ¶sterirler.

````
public class Car {
    // nitelikler
    String type;
    String model;
    String color;
    int speed;

    // davranÄ±ÅŸlar
    int increaseSpeed(int increment) {
        speed += increment;
        return speed;
    }

    int decreaseSpeed(int decrease) {
        if (speed > 0) {
            speed -= decrease;
        }
        return speed;
    }
    
    void printSpeed() {
        System.out.println("Speed : " + speed);
    }
    // ...
}
````
Java'da nesne Ã¼retmek iÃ§in kullanÄ±lan sÃ¶zdizimi :

````
ClassName object = new ClassName();  
````
1. ClassName : Nesne oluÅŸturmak istediÄŸimiz sÄ±nÄ±fÄ± belirtiyoruz. Bu sÄ±nÄ±f daha Ã¶ncesinde projemizde tanÄ±mlanmÄ±ÅŸ olmasÄ± gerekmektedir. 
2. object : Nesnemize verdiÄŸimiz isimdir ve aynÄ± isimde birden fazla nesne oluÅŸturulamaz. 
3. new : Java'da nesne Ã¼retmek iÃ§in "new" anahtar kelimesini kullanÄ±rÄ±z. 
4. ClassName(); : SÄ±nÄ±fa ait Kurucu (Constructor) Metodu temsil eder. VarsayÄ±lan olarak parametresiz tanÄ±mlanÄ±r. 

Car sÄ±nÄ±fÄ±na ait Ã¶rnek nesne oluÅŸturma :

````
Car audi = new Car();
Car bmw = new Car();
Car mercedes = new Car();
````
YukarÄ±daki Ã¶rnekte "Car" sÄ±nÄ±fÄ±na ait 3 tane farklÄ± nesne Ã¼rettik. Bu nesnelerin her birinin nitelikleri farklÄ± olmakla beraber hafÄ±zada ayrÄ± ayrÄ± yer kaplamaktadÄ±rlar.


### SÄ±nÄ±f Niteliklerine EriÅŸim


SÄ±nÄ±flara ait niteliklere eriÅŸim saÄŸlamak iÃ§in nokta (.) kullanÄ±lÄ±r. Ä°lgili nesnenin ismini sonuna nokta koyularak eriÅŸilmek istenilen niteliÄŸin ismi yazÄ±lÄ±r.

````
public class Main {
    public static void main(String[] args) {
        Car audi = new Car();
        audi.speed = 10;
        System.out.println("Audi HÄ±zÄ± : " + audi.speed);

        Car bmw = new Car();
        bmw.speed = 25;
        System.out.println("Bmw HÄ±zÄ± : " + bmw.speed);

        Car mercedes = new Car();
        mercedes.speed = 30;
        System.out.println("Mercedes HÄ±zÄ± : " + mercedes.speed);

    }
}
````
ProgramÄ±n Ã§Ä±ktÄ±sÄ± :

````
Audi HÄ±zÄ± : 10
Bmw HÄ±zÄ± : 25
Mercedes HÄ±zÄ± : 30
````
### SÄ±nÄ±f MetotlarÄ±na EriÅŸim


SÄ±nÄ±fa ait davranÄ±ÅŸlara yani metotlara eriÅŸmek iÃ§in nokta (.) kullanÄ±lÄ±r. Ä°lgili nesnenin ismini sonuna nokta koyularak eriÅŸilmek istenilen metodun ismi yazÄ±lÄ±r ve var ise parametreleri girilir.

````
public class Main {
    public static void main(String[] args) {
        Car audi = new Car();
        audi.speed = 10;
        audi.increaseSpeed(20);
        audi.printSpeed();

        Car bmw = new Car();
        bmw.increaseSpeed(10);
        bmw.increaseSpeed(25);
        bmw.increaseSpeed(5);
        bmw.decreaseSpeed(25);
        bmw.printSpeed();

        Car mercedes = new Car();
        mercedes.speed = 20;
        mercedes.printSpeed();

    }
}
````
ProgramÄ±n Ã§Ä±ktÄ±sÄ± :

````
Speed : 30
Speed : 15
Speed : 20
````

# ğŸ“— Constructor (YapÄ±cÄ±) Metot KullanÄ±mÄ±

Kurucu metotlar sÄ±nÄ±f tasarlanÄ±rken yazÄ±lÄ±rlar. SÄ±nÄ±fÄ±nÄ±zÄ± yazarken kurucu metotlarÄ±nÄ±zÄ± da tanÄ±mlayabilirsiniz. EÄŸer sÄ±nÄ±f iÃ§inde hiÃ§ kurucu metot tanÄ±mlamazsÄ±nÄ±z parametresiz boÅŸ bir kurucu metot Java tarafÄ±ndan otomatik olarak tanÄ±mlanÄ±r.


Kurucu metotlar ilgili sÄ±nÄ±ftan bir nesne Ã¼retmeye Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±zda daha nesne Ã¼retme aÅŸamasÄ±nda Ã§alÄ±ÅŸtÄ±rÄ±lan Ã¶zel metotlardÄ±r (fonksiyonlardÄ±r). Kurucu metotlarÄ±n isimleri SÄ±nÄ±f ismiyle aynÄ± olmak zorundadÄ±r. DÃ¶nÃ¼ÅŸ tipi olarak veya void olarak herhangi bir tanÄ±mlama yapÄ±lmasÄ±na gerek yoktur.


"new" anahtar kelimesi ile nesne Ã¼retirken kurucu metot Ã§aÄŸrÄ±mÄ± yapÄ±lÄ±r. Ä°ki tip kurucu metot vardÄ±r:


1. Parametresiz VarsayÄ±lan Kurucu Metot 
2. Parametreli Kurucu Metot 

Car sÄ±nÄ±fÄ±mÄ±z :

````
public class Car {
    // nitelikler
    String type;
    String model;
    String color;
    int speed;

    // Constructor (Kurucu) Metot
    Car(String type, String model, String color) {
        this.type = type;
        this.model = model;
        this.color = color;
        this.speed = 0;
    }

    // davranÄ±ÅŸlar
    int increaseSpeed(int increment) {
        speed += increment;
        return speed;
    }

    int decreaseSpeed(int decrease) {
        if (speed > 0) {
            speed -= decrease;
        }
        return speed;
    }

    void printSpeed() {
        System.out.println("Speed : " + speed);
    }

    void printInfo() {
        System.out.println("================");
        System.out.println("Model : " + this.model);
        System.out.println("Color : " + this.color);
        System.out.println("Type : " + this.type);
        System.out.println("Speed : " + this.speed);
    }
    // ...
}
````
Nesnelerimiz :

````
public class Main {
    public static void main(String[] args) {
        Car audi = new Car("Sports", "Audi", "red");
        audi.increaseSpeed(20);
        audi.printInfo();

        Car bmw = new Car("Sports" , "BMW" , "blue");
        bmw.increaseSpeed(10);
        bmw.increaseSpeed(25);
        bmw.increaseSpeed(5);
        bmw.decreaseSpeed(25);
        bmw.printInfo();

        Car mercedes = new Car("Corporate" , "Mercedes" , "black");
        mercedes.speed = 20;
        mercedes.printInfo();

    }
}
````
ProgramÄ±n Ã§Ä±ktÄ±sÄ± :

````
================
Model  : Audi
Color  : red
Type  : Sports
Speed  : 20
================
Model  : BMW
Color  : blue
Type  : Sports
Speed : 15 ================
Model  : Mercedes
Color  : black
Type  : Corporate
Speed  : 20
````

# ğŸ“— Tek Boyutlu Diziler

Tek boyutlu diziler basitÃ§e, aynÄ± tÃ¼rden elemanlarÄ±n listesini tutan bir yapÄ±dÄ±r. Dizi oluÅŸturmak iÃ§in, Ã¶nce dizide yer alacak elemanlarÄ±n tÃ¼rÃ¼ belirtilir, sonra diziye bir isim verilir ve isimden sonra kÃ¶ÅŸeli parantezler ( [ ve ] ) konulur.

````
int numbers[]; // Burada numbers isminde bir dizi oluÅŸturuluyor
````
KÃ¶ÅŸeli parantezleri deÄŸiÅŸken isminden sonra koymak yerine, tÃ¼r isminden sonra da yazabilirsiniz. Ã–rneÄŸin aÅŸaÄŸÄ±daki kodun yukarÄ±dakiyle bir farkÄ± yoktur:

````
int[] numbers; // Burada numbers isminde bir dizi oluÅŸturuluyor
````
Diziler new deyimiyle oluÅŸturulur. Dizi oluÅŸtururken kapasite deÄŸeri vermek zorunludur. Kapasite deÄŸeri, dizinin kaÃ§ eleman barÄ±ndÄ±racaÄŸÄ±nÄ± belirtir. AÅŸaÄŸÄ±daki Ã¶rnekte, 5 adet int deÄŸiÅŸkeni tutabilecek bir dizi oluÅŸturuluyor:

````
int[] numbers = new int[5];
````
Bu ifade Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda, hafÄ±zada 5 adet int deÄŸiÅŸken iÃ§in yetecek kadar alan ayrÄ±lÄ±r. Bu alanÄ± dÃ¼zenleyebilmek iÃ§in indeks numaralarÄ± kullanÄ±rÄ±z. Dizi indeksleri 0â€™dan baÅŸlar ve kapasitenin 1 eksiÄŸine kadar gider. Ã–rneÄŸin, yukarÄ±daki dizinin indeksleri 0â€™dan 4â€™e kadardÄ±r. Åimdi bu dizinin ilk elemanÄ±nÄ± verelim:

````
numbers[0] = 10; // Dizinin ilk elemanÄ± 10 olarak ayarlandÄ±.
````
Dizinin diÄŸer elemanlarÄ±nÄ± ÅŸu ÅŸekilde verelim:

````
numbers[1] = 15;
numbers[2] = 20;
numbers[3] = 25;
numbers[4] = 30;
````
Bu kodlar Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda dizinin elemanlarÄ± sÄ±rasÄ±yla aÅŸaÄŸÄ±daki gibi olur:

````
{ 10, 15, 20, 25, 30 }
````

AÅŸaÄŸÄ±daki kodu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ±zda konsola 25 yazar:

````
System.out.println(numbers[3]);
````
Dizilerle uÄŸraÅŸÄ±rken indeks numaralarÄ±na Ã§ok dikkat etmelisiniz. EÄŸer dizinin aralÄ±ÄŸÄ± dÄ±ÅŸÄ±nda bir indekse eriÅŸmeye Ã§alÄ±ÅŸÄ±rsanÄ±z, *IndexOutOfBoundsException* hatasÄ± meydana gelir.

````
System.out.println(numbers[5]); // Hata!
````
YukarÄ±daki satÄ±r hataya neden olur; Ã§Ã¼nkÃ¼ numbers dizisinin kapasitesi 5 olmasÄ±na raÄŸmen dizinin 6. elemanÄ±na eriÅŸmeye Ã§alÄ±ÅŸÄ±yoruz.


EÄŸer dizinin iÃ§indeki elemanlar dizi oluÅŸturulurken belliyse, diziyi oluÅŸtururken elemanlarÄ± kÃ¼me parantezi iÃ§inde ve virgÃ¼lle birbirinden ayÄ±rarak verebiliriz:

````
String[] weekDays = new String[] { "Pazartesi", "SalÄ±", "Ã‡arÅŸamba", "PerÅŸembe", "Cuma", "Cumartesi", "Pazar" };
````
Bu ÅŸekilde oluÅŸturulan dizilere kapasite vermemize gerek yoktur; Ã§Ã¼nkÃ¼ kapasite deÄŸeri zaten eleman sayÄ±sÄ±ndan bellidir. YukarÄ±daki Ã¶rnekte weekDays dizisinin kapasitesi otomatik olarak 7 olur.


YukarÄ±daki gibi dizi oluÅŸtururken new deyimini kullanmaya gerek yoktur. Yani, yukarÄ±daki kodu aÅŸaÄŸÄ±daki gibi yazabiliriz:

````
String[] weekDays = { "Pazartesi", "SalÄ±", "Ã‡arÅŸamba", "PerÅŸembe", "Cuma", "Cumartesi", "Pazar" };
````
### Dizinin Kapasitesini Ã–ÄŸrenmek


Her dizinin length adÄ±nda bir Ã¶zelliÄŸi bulunur. Bu Ã¶zelliÄŸi kullanarak dizinin kapasitesini Ã¶ÄŸrenebilirsiniz.


Ã–rneÄŸin, aÅŸaÄŸÄ±daki kodu inceleyelim:

````
int[] numbers = new int[100];
System.out.println(numbers.length); // Konsolda 100 yazar
````
### Dizinin Bir ElemanÄ±nÄ± DeÄŸiÅŸtirme

````
String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
cars[0] = "Opel";
cars[2] = "Toyota";

System.out.println(cars[0]);
````

# ğŸ“— Ã‡ok Boyutlu Diziler

Java'da Ã‡ok Boyutlu Diziler varsayÄ±lan bir veri tipi olarak bulunmazlar ve matris olarak adlandÄ±rÄ±lÄ±rlar. Dizilerin 2 boyutlu halleri ÅŸeklinde tanÄ±mlanÄ±rlar. Matrisler satÄ±r ve sÃ¼tun ÅŸeklinde tablo verisi formatÄ±ndaki verileri tutmak iÃ§in kullanÄ±lÄ±r. Diziler liste halinde veriler iÃ§in uygunken, matrisler tablo ÅŸeklindeki veriler iÃ§in uygundur. OluÅŸturulan tabloda bir deÄŸere ulaÅŸmak istersek satÄ±r ve sÃ¼tun sayÄ±sÄ±nÄ± girmemiz yeterli olacaktÄ±r.


Ä°ki boyutlu dizilerde tek boyutlu diziler gibi indis deÄŸeri 0'dan baÅŸlar. Dizide tutulacak veri tipleri aynÄ± olmak zorundadÄ±r farklÄ± veri tiplerini aynÄ± matriste tutamayÄ±z.


3x3 boyutunda bir matris Ã¶rneÄŸi :

![img_4.png](img_4.png)


Tablo oluÅŸturup bu tablonun bilgilerini matris ile gÃ¶sterelim. Ã–rneÄŸin, ÅŸehirler arasÄ±ndaki mesafeyi gÃ¶steren bu tabloyu uzaklÄ±k deÄŸiÅŸkenimizde sakladÄ±k.


Mesafe Tablosu(KM)

![img_5.png](img_5.png)

````
int[][] uzaklik ={
                {0, 453, 939, 243, 783, 891},
                {453, 0, 490, 384, 620, 439},
                {939, 490, 0, 839, 863, 423},
                {243, 384, 839, 0, 544, 823},
                {783, 620, 863, 544, 0, 1045},
                {891, 439, 423, 823, 1045, 0}
        };
````
### Ä°ki Boyutlu Dizi TanÄ±mlama YÃ¶ntemleri


Ä°ki boyutlu dizileri oluÅŸturmanÄ±n farklÄ± yÃ¶ntemleri var ÅŸimdi bunlara bakalÄ±m.


Bir deÄŸiÅŸkenin dizi olduÄŸunu kÃ¶ÅŸeli parantezler ile belirtmiÅŸtik. Bir tane kÃ¶ÅŸeli parantez tek boyutlu dizi belirtir. EÄŸer Ã§ok boyutlu dizi oluÅŸturmak istiyorsak, boyut sayÄ±sÄ± kadar kÃ¶ÅŸeli parantez belirtmeliyiz. Ã–rneÄŸin aÅŸaÄŸÄ±daki satÄ±r 2 boyutlu bir dizi (yani matris) belirtir:

````
degiskenTipi[][] arrayIsmi;
int matrix[][];
````
yada

````
degiskenTipi arrayIsmi[][];  //bu yÃ¶ntem tercih edilmez
````
Ä°ki boyutlu dizimizi tanÄ±mlarken deÄŸerlerini atamak istersek aÅŸaÄŸÄ±daki yÃ¶ntemi kullanabiliriz.

````
int[][] array = {
{1, 2, 3}, 
{4, 5, 6}, 
{7, 8, 9}, 
{10, 11, 12} 
};
````
Ä°lk kÃ¶ÅŸeli parantez birinci boyutu (satÄ±rlarÄ±), diÄŸeri ise ikinci boyutu (sÃ¼tunlarÄ±) belirtir. AÅŸaÄŸÄ±daki kodu Ã§alÄ±ÅŸtÄ±rÄ±rsak, 3 satÄ±rlÄ± ve 4 sÃ¼tunlu bir matris oluÅŸturur:

````
int matrix[][] = new int[3][4];
````
yada

````
matrix = new int[3][4];
````
oluÅŸturulan matrix deÄŸiÅŸkeninin default deÄŸeri (a) ile gÃ¶sterilen tablodaki gibidir.

````
[0][1][2][3]
[0] 0 0 0 
[1] 0 0 0 
[2] 0 0 0 

    (a)
````
Bu matrisin bÃ¼tÃ¼n elemanlarÄ±na ulaÅŸmak iÃ§in kullanmamÄ±z gereken indeks numaralarÄ±nÄ± aÅŸaÄŸÄ±daki tabloda gÃ¶rebilirsiniz:

![img_6.png](img_6.png)

````
matrix[1][2]; // Matrisin 2. satÄ±r ve 3. sÃ¼tunundaki elemana eriÅŸiliyor
matrix[0][3]; // Matrisin 1. satÄ±r ve 4. sÃ¼tunundaki elemana eriÅŸiliyor
matrix[2][0]; // Matrisin 3. satÄ±r ve 1. sÃ¼tunundaki elemana eriÅŸiliyor
````
Matrisin 2. satÄ±rÄ± ve 3. sÃ¼tununda yer alan deÄŸerini 7 yapalÄ±m.

````
matrix[2][1] = 7;
````
AtadÄ±ÄŸÄ±mÄ±z 7 deÄŸerine ulaÅŸmak istersek matrix[2] [][][1] ifadesini kullanÄ±rÄ±z.


Fark ettiÄŸiniz gibi matrislerin dizilerden tek farkÄ± [] parantez yanÄ±na bir tane [] aÃ§Ä±yoruz. Zaten her [] ifadesi yeni bir boyut anlamÄ±na geliyor. "double[][][] ucBoyutlu;" ÅŸeklinde bir ifadeyle 3 boyutlu veri saklayan bir veri yapÄ±sÄ± oluÅŸturmuÅŸ oluyoruz.


Åimdi gÃ¼zel bir Ã¶rnek yapalÄ±m. 3 satÄ±rdan ve 4 sÃ¼tundan oluÅŸan bir matris yaratalÄ±m ve bu matrisin elemanlarÄ±nÄ± sÄ±rayla 1â€™den baÅŸlayacak ÅŸekilde dolduralÄ±m. AÅŸaÄŸÄ±daki kodu inceleyelim:

````
int[][] matrix = new int[3][4];
int number = 1;

for (int x = 0; x < matrix.length; x++)
{
	int[] row = matrix[x];

    for (int y = 0; y < row.length; y++)
	{	
		row[y] = number;
		number++;
	}
}
````
Åimdi yukarÄ±daki kodu inceleyelim. Ä°ki boyutlu diziyi oluÅŸturduktan sonra Ã¶nce for dÃ¶ngÃ¼sÃ¼yle dizinin satÄ±rlarÄ±nÄ± geziyoruz. Daha sonra iÃ§erideki for dÃ¶ngÃ¼sÃ¼yle dizinin sÃ¼tunlarÄ±nÄ± dolaÅŸÄ±yoruz. Bu Ã¶rneÄŸi vermemizdeki amaÃ§, matrisin elemanlarÄ±na ulaÅŸmak iÃ§in iÃ§ iÃ§e 2 for dÃ¶ngÃ¼sÃ¼ kullanmak gerektiÄŸini gÃ¶stermektir. AyrÄ±ca dizinin length metodunun faydasÄ±nÄ± da burada gÃ¶rmÃ¼ÅŸ oluyoruz.


YukarÄ±daki kod Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda matrisin elemanlarÄ± ÅŸu ÅŸekilde olur:

![img_7.png](img_7.png)


### Ä°Ã§ Ä°Ã§e DÃ¶ngÃ¼lerle Dizilere EriÅŸim ve Dizi Ä°ÅŸlemleri


AÅŸaÄŸÄ±daki kod bize bi matris deÄŸerini ekrana nasÄ±l yazdÄ±racaÄŸÄ±mÄ±zÄ± gÃ¶sterir. DÃ¶ngÃ¼ye girdikten sonra her sÃ¼tun sayÄ±sÄ± her satÄ±r iÃ§in tek tek ekrana bastÄ±rÄ±lÄ±r. Her bir satÄ±rÄ±n tamamlanmasÄ±ndan sonra System.out.println() ile bir alt satÄ±ra geÃ§ilir.

````
for (int row = 0; row < matrix.length; row++) {
   for (int column = 0; column < matrix[row].length; column++) {
       System.out.print(matrix[row][column] + " "); 
}
    System.out.println(); 
}
````
Ä°ki boyutlu diziler aslÄ±nda her satÄ±rÄ±nÄ±n tek boyutlu olduÄŸu dizilerdir. Ã‡ok boyutlu dizilerinde boyutuna ulaÅŸarak iÅŸlem yapabiliriz.


Ã–rneÄŸin x = new int[3] [][][4] arrayinin x[0], x[1], x[2] deÄŸerleri tek boyutlu dizidir. Ve her biri aÅŸaÄŸÄ±daki ÅŸekilde gÃ¶sterildiÄŸi gibi 4 elemanÄ± vardÄ±r. x.length deÄŸeri 3'tÃ¼r, yani bize sahip olduÄŸu 3 satÄ±rÄ±n deÄŸerini verir. SÃ¼tun sayÄ±sÄ±na ise her hangi bir satÄ±r deÄŸerinin uzunluÄŸu kadardÄ±r. x[2].length deÄŸeri 4'tÃ¼r.


YukarÄ±da Ã¶ÄŸrendiÄŸimiz konularÄ± pekiÅŸtirmek adÄ±na aÅŸaÄŸÄ±daki kodu inceleyelim.

````
public double[][] multiplyMatrices(double[][] firstMatrix, double[][] secondMatrix) {

	// firstMatrix.length ile ilk matrisin satÄ±r sayÄ±sÄ±nÄ± buluyoruz. Ã¶rneÄŸimizde 3 olarak gelecektir.
	// secondMatrix[0].length ile ikinci matrisin sÃ¼tun sayÄ±sÄ±nÄ± buluyoruz. Ã¶rneÄŸimizde 4 olarak gelecektir.

	// C matrisi olacak olan matrisi tanÄ±mlÄ±yoruz.
    double[][] result = new double[firstMatrix.length][secondMatrix[0].length];
 
 	// matrislerde Ã§arpma, toplama gibi iÅŸlemleri yapabilmek iÃ§in iÃ§ iÃ§e 3 tane dÃ¶ngÃ¼ye ihtiyaÃ§ duyarÄ±z.
    for (int row = 0; row < result.length; row++) {
        for (int col = 0; col < result[row].length; col++) {
            result[row][col] = multiplyMatricesCell(firstMatrix, secondMatrix, row, col);
        }
    }
 
    return result;
}
````
````
double multiplyMatricesCell(double[][] firstMatrix, double[][] secondMatrix, int row, int col) {
	// A matrisinin satÄ±rÄ± ile B matrisinin sÃ¼tunu Ã§arpma iÅŸlemi.
	/*
	*   row = 3, col = 4  olarak gelecektir.
	*   i = 0 ise
	*   firstMatrix[3][0] * secondMatrix[0][4] 
	*   i = 1 ise
	*   firstMatrix[3][1] * secondMatrix[1][4] 
	*   i = 2 ise
	*   firstMatrix[3][2] * secondMatrix[2][4] 
	* ÅŸeklinde i deÄŸiÅŸerek satÄ±r ve sÃ¼tun Ã§arpÄ±lÄ±r.
	*/
    double cell = 0;
    for (int i = 0; i < secondMatrix.length; i++) {
        cell += firstMatrix[row][i] * secondMatrix[i][col];
    }
    return cell;
}
````
YukarÄ±daki â€œmultiplyMatricesâ€ fonksiyonu iki tane matrisi girdi olarak alÄ±r. Fonksiyon matrislerin Ã§arpÄ±m sonucunu matris olarak dÃ¶ndÃ¼rÃ¼r.


â€œmultiplyMatricesâ€ fonksiyonu iÃ§inde bir baÅŸka fonksiyon daha Ã§aÄŸrÄ±lmÄ±ÅŸtÄ±r. â€œmultiplyMatricesCellâ€ bu fonksiyon ise iki matrisin satÄ±r ve sÃ¼tununu Ã§arpÄ±p sonucu double tipte bir deÄŸer dÃ¶ndÃ¼rÃ¼r.


### SÃ¼tun Kapasiteleri FarklÄ± Matris OluÅŸturmak - DÃ¼zensiz Diziler


FarklÄ± sÃ¼tun deÄŸerine sahip dizilere "Ragged Arrays" yani dÃ¼zensiz diziler denir. BaÅŸka bir aÃ§Ä±dan bakÄ±ldÄ±ÄŸÄ±nda ise, 2 boyutlu dizileri, dizilerin dizisi (array of arrays) olarak dÃ¼ÅŸÃ¼nmek doÄŸru olur. Yani iki boyutlu dizileri tek boyutlu diziler oluÅŸturur.


Diziler aynÄ± tÃ¼rden elemanlardan oluÅŸmak zorundadÄ±r. int tÃ¼rÃ¼nde bir dizi olabileceÄŸi gibi, dizinin dizisi de olabilir.


YukarÄ±daki Ã¶rneklerde matrisin sÃ¼tun sayÄ±sÄ±nÄ± 4 olarak belirledik. Bu ÅŸekilde oluÅŸturulursa matrisin bÃ¼tÃ¼n satÄ±rlarÄ± 4 elemanlÄ± olur. Fakat bu zorunlu deÄŸildir. Matris oluÅŸtururken sÃ¼tun sayÄ±sÄ± belirlemezsek, her bir satÄ±rdaki dizilerin kapasitesi farklÄ± olabilir. Ã–rneÄŸin aÅŸaÄŸÄ±daki kodu inceleyelim:

````
int[][] matrix = new int[3][];
matrix[0] = new int[1];
matrix[1] = new int[2];
matrix[2] = new int[3];
````
Burada Ã¶nce 3 satÄ±rdan oluÅŸan bir matris belirttik, fakat sabit bir sÃ¼tun sayÄ±sÄ± vermedik. Sonra her bir satÄ±r iÃ§in ayrÄ± ayrÄ± sÃ¼tun sayÄ±sÄ± belirledik.


Ã‡ok boyutlu dizi oluÅŸtururken, yalnÄ±zca ilk boyutun (en soldaki) kapasitesini belirlemeniz yeterlidir. DiÄŸer boyutlarÄ±n kapasitesini dinamik olarak belirleyebilirsiniz.


### AlÄ±ÅŸtÄ±rma


AÅŸaÄŸÄ±da verilen Ã¶rneklerin cevaplarÄ±na bakmadan Ã¶nce kendiniz kodlamaya Ã§alÄ±ÅŸmanÄ±zÄ± Ã¶neririz. Daha sonra zorlandÄ±ÄŸÄ±nÄ±z noktalarda ufak yardÄ±mlar almak iÃ§in bakabilirsiniz. Bu sizin Ã¶ÄŸrenmenize daha yardÄ±mcÄ± olacaktÄ±r.


Matris boyutunu sizin belirlediÄŸiniz matris deÄŸerlerini ise kullanÄ±cÄ±nÄ±n girdiÄŸi bir algoritma yazÄ±nÄ±z.


Cevap:

````
int matrix[][] = new int[3][4];
        Scanner input = new Scanner(System.in);
        System.out.println("Enter " + matrix.length + " rows and "
                + matrix[0].length + " columns: ");
        for (int row = 0; row < matrix.length; row++) {
            for (int column = 0; column < matrix[row].length; column++) {
                matrix[row][column] = input.nextInt();
            }
        }
````
Ä°stediÄŸiniz boyutta matris oluÅŸturarak matris deÄŸerlerine 0-99 arasÄ± random sayÄ±lar Ã¼reterek matrise atama yapÄ±nÄ±z.


Cevap:

````
int[][] matrix = new int[3][4];
        for (int row = 0; row < matrix.length; row++) {
            for (int column = 0; column < matrix[row].length; column++) {
                matrix[row][column] = (int) (Math.random() * 100);
            }
        }
````
AÅŸaÄŸÄ±daki kod bloÄŸunun Ã§Ä±ktÄ±sÄ± nedir?

````
  int[][] array = {{1, 2}, {3, 4}, {5, 6}};
        for (int i = array.length - 1; i >= 0; i--) {
            for (int j = array[i].length - 1; j >= 0; j--) {
                System.out.print(array[i][j] + " ");
            }
            System.out.println();
        }
````
Cevap:

````
6 5 
4 3 
2 1 
````

# ğŸ“— ForEach KullanÄ±mÄ±

ava'da ForEach deyimi adÄ±nda da anlaÅŸÄ±lacaÄŸÄ± gibi bir dÃ¶ngÃ¼yÃ¼ ifade eder. Genelde dizilerdeki ve listelerdeki elemanlarÄ± daha hÄ±zlÄ± ÅŸekilde ulaÅŸmak iÃ§in kullanÄ±lan kÄ±sa bir yÃ¶ntemdir. KÄ±sacasÄ± for dÃ¶ngÃ¼sÃ¼nÃ¼n modifiye edilmiÅŸ halidir.

````
for (veritipi degisken: diziAdi) {
  // kod bloÄŸu
}
````
Ã–rnekte Java'da ForEach kullanÄ±mÄ±nÄ± gÃ¶rmektesiniz, yine bir for dÃ¶ngÃ¼sÃ¼ oluÅŸturuyoruz ama iki parametreyi iki nokta ile ayÄ±rÄ±yoruz. Ä°lk kÄ±smÄ±nda dizinin dÃ¶ndÃ¼receÄŸi veri tipini ve for iÃ§inde dizinin elemanÄ± olarak kullanacaÄŸÄ±nÄ±z deÄŸiÅŸkeni tanÄ±mlÄ±yorsunuz, diÄŸer kÄ±sÄ±mda ise dizimizin ismini yazÄ±yoruz.


Bu Ã¶rneÄŸimizde arabalar dizisinin forEach ile nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rmektesiniz.

````
String[] arabalar = {"BMW", "Mercedes", "Ford", "Ferrari"};
for (String i : arabalar) {
  System.out.println(i);
}

// Ã‡Ä±ktÄ±sÄ±
// BMW
// Mercedes
// Ford
// Ferrari 
````
Ã‡ok boyutlu dizilerde forEach kullanÄ±mÄ±

````
public class Main {public static void main(String[] args) {
        int[][] matris = {
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9},
                {10, 11, 12}
        };

        for (int[] u : matris) {
            for (int elem : u) {
                System.out.println(elem);
            }
        }
    }
}
````

# ğŸ“— Arrays SÄ±nÄ±fÄ± ve MetotlarÄ±

Java.util paketindeki Arrays sÄ±nÄ±fÄ±, Java Collection Framework'Ã¼n bir parÃ§asÄ±dÄ±r. Bu sÄ±nÄ±f, Java dizilerini dinamik olarak oluÅŸturmak ve bunlara eriÅŸmek iÃ§in statik metotlar saÄŸlar. YalnÄ±zca statik metotlar ve Object sÄ±nÄ±fÄ±nÄ±n metotlarÄ±ndan oluÅŸur. Bu sÄ±nÄ±fÄ±n metotlarÄ±, sÄ±nÄ±f adÄ±nÄ±n kendisi tarafÄ±ndan kullanÄ±labilir.

````
import java.util.Arrays;
````
Import deyimi ile java.util.Arrays sÄ±nÄ±fÄ±nÄ± projeye dahil etmemiz gerekmektedir.


### Arrays.toString()


Diziye ait elemanlarÄ± direk ekrana basmak iÃ§in kullanÄ±lan bir metottur.

````
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] dizi = {3, 5, 79, 12, 25, -3, 66, 82, -49, 152};
        System.out.println(Arrays.toString(dizi));
    }
}

// Ã‡Ä±ktÄ±sÄ±
// [3, 5, 79, 12, 25, -3, 66, 82,-49,152]
````
### Arrays.fill()


Arrays.fill metodu ile dizilerimizin belirli bir bÃ¶lÃ¼mlerine deÄŸerler atayabiliriz.

````
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] liste = {15, 1, 99, 7, 7, -22, 11, 2, -49, 52};

        Arrays.fill(liste, 2);
        System.out.println(Arrays.toString(liste));

        int[] liste2 = {15, 1, 99, 7, 7, -22, 11, 2, -49, 52};

        Arrays.fill(liste2, 3, 5, 7);
        System.out.println(Arrays.toString(liste2));
    }
}

// Ã‡Ä±ktÄ±sÄ±
// [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
// [15, 1, 99, 7, 7, -22, 11, 2, -49, 52]
````
### Arrays.sort()


Arrays.sort() metodu ile dizilerdeki elemanlarÄ± sÄ±ralayabiliriz.


import java.util.Arrays;
````
public class Main {
    public static void main(String[] args) {
        int[] liste = {6, 1, 55, 21, 33, -321, -21, 2, -11, 27};
        Arrays.sort(liste);
        System.out.println(Arrays.toString(liste));
    }
}
// Ã‡Ä±ktÄ±sÄ±
// [-321, -21, -11, 1, 2, 6, 21, 27, 33, 55]
````
### Arrays.binarySearch()


Java'da dizideki bir elemanÄ±n indis deÄŸerini bulmak iÃ§in binarySearch kullanÄ±labilir. Ama bu metodu kullanabilmek iÃ§in, dizinin sÄ±ralÄ± olmasÄ± gerekmektedir.

````
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] liste = {6, 1, 55, 21, 33, -321, -21, 2, -11, 27};

        Arrays.sort(liste);
        System.out.println(Arrays.toString(liste));

        int index = Arrays.binarySearch(liste, 33);
        System.out.println("33'Ã¼n indeksi :" + index);
    }
}
// [-321, -21, -11, 1, 2, 6, 21, 27, 33, 55]
// 33'Ã¼n indeksi :8
````
### Arrays.copyOf() ve Arrays.copyOfRange() metotu


Mevcut diziden belli bir uzunlukta yeni bir dizi oluÅŸturmak iÃ§in Arrays.copyOf() metotu kullanÄ±lÄ±r


Mevcut diziden belli bir aralÄ±kta yeni bir dizi oluÅŸturmak iÃ§in ise Array.copyOfRange() metodu kullanÄ±lÄ±r.

````
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] liste = {6, 1, 55, 21, 33, -321, -21, 2, -11, 27};

        int[] copyArray = Arrays.copyOf(liste, 3);
        System.out.println(Arrays.toString(copyArray));

        int[] copyOfRangeArray = Arrays.copyOfRange(liste, 0,5);
        System.out.println(Arrays.toString(copyOfRangeArray));
    }
}
// [6, 1, 55]
// [6, 1, 55, 21, 33]
````
### Arrays.equals() metotu


Java'da iki dizinin eÅŸitliÄŸini kontrol etmek iÃ§in Arrays.equals() metotu kullanÄ±lÄ±r.

````
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] list1 = {1, 2, 3};
        int[] list2 = {1, 2, 3};
        int[] list3 = {1, 2, 10};

        System.out.println(Arrays.equals(list1, list2)); // true
        System.out.println(Arrays.equals(list2, list3)); // false
    }
}
````

